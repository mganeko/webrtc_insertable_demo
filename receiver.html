<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <title>Receiver</title>
  <script src="https://unpkg.com/@open-ayame/ayame-web-sdk@2022.1.0/dist/ayame.min.js"></script>
</head>

<body>
  <div>
    WebRTC RTCRtpScriptTransforms (<a
      href="https://www.w3.org/TR/webrtc-encoded-transform/#scriptTransform">draft Spec</a>) Trial.<br />
    Please try with Safari 16, Firefox 117(beta) or later.
  </div>
  <br />
  <button onclick="startConn()">Connect</button>
  <button onclick="stopConn()">Disconnect</button>
  <br />
  <div
    style="display:grid; grid-template-columns: 400px; grid-template-rows: 30px 250px 30px; column-gap: 2px; row-gap: 2px;">
    <div>Receiver</div>
    <video id="recv_video" width="320" height="240" controls="1" style="border: solid 1px black;">
    </video>
    <div><input type="checkbox" id="invert_receiver_check" onchange="toggleReceiver()">XOR Receiver data</input></div>
  </div>
</body>
<script>
  //
  // Refer:
  //   - https://github.com/alvestrand/webrtc-media-streams/blob/master/explainer.md
  //   - https://github.com/webrtc/samples/tree/gh-pages/src/content/peerconnection/endtoend-encryption
  //   - https://github.com/webrtc/samples/blob/gh-pages/src/content/peerconnection/endtoend-encryption/js/worker.js
  // 

  let localStream = null;
  let pipe = null;
  let invertSender = false;
  let invertReceiver = false;
  //const localVideo = document.getElementById('local_video');
  const recvVideo = document.getElementById('recv_video');

  function toggleReceiver() {
    invertReceiver = document.getElementById('invert_receiver_check').checked;
    console.log('invertReceiver=', invertReceiver);
    postEncryptFlag();
  }


  // --- check if supports InsertableStreams ---
  const supportsInsertableStreams =
    !!RTCRtpSender.prototype.createEncodedStreams;
  console.log('supportsInsertableStreams=', supportsInsertableStreams);
  const supportsScriptTransform =
    !!window.RTCRtpScriptTransform;
  console.log('supportsScriptTransform=', supportsScriptTransform);

  // --- worker ---
  const worker = new Worker('./js/worker.js', {name: 'E2EE worker'});
  let encodedStreams = [];

  function setupReceiverTransform(receiver) {
    console.log('receiver kind=%s', receiver.track.kind);
    if (window.RTCRtpScriptTransform) {
      if (receiver.transform) {
        console.log('receiver.transform already exists');
        return;
      }
      receiver.transform = new RTCRtpScriptTransform(worker, {operation: 'decode'});
      return;
    }
    else if(supportsInsertableStreams) {
      if (encodedStreams[receiver.track.kind]) {
        console.log('receiver.transform already exists');
        return;
      }
      const receiverStreams = receiver.createEncodedStreams();
      encodedStreams[receiver.track.kind] = receiverStreams;
      const {readable, writable} = receiverStreams;
      worker.postMessage({
        operation: 'decode',
        readable,
        writable,
      }, [readable, writable]);
    }
    else {
      console.error('ERROR: NOT support RTCRtpScriptTransform');
      throw new Error('NOT support RTCRtpScriptTransform');
    }
  }

  // encript on/off
  function postEncryptFlag() {
    worker.postMessage({
      operation: 'setEncript',
      encriptSender: invertSender,
      encriptReceiver: invertReceiver,
    });
  }

/* ======== for Ayame Labo ======== */
const conn = Ayame.connection('wss://ayame-labo.shiguredo.app/signaling', 'mg-test-room');
conn.options.video.direction = 'recvonly';
conn.options.audio.direction = 'recvonly';
conn._pcConfig.encodedInsertableStreams = true;
const startConn = async () => {
  await conn.connect(null).catch(e => console.log(e));
  console.log('ayame connected');
  
  conn.on('disconnect', (e) => {
    console.log(e);
    encodedStreams = [];
  });
  conn.on('addstream', (e) => {
    console.log('addstream', e.stream);
    conn._pc.getReceivers().forEach(setupReceiverTransform);

    //  document.querySelector('#remote-video').srcObject = e.stream;
    if (!recvVideo.srcObject) {
      recvVideo.srcObject = e.stream;
      recvVideo.play().catch(err => { console.error('play ERROR', err) });
    }
    else if (recvVideo.srcObject !== e.stream) {
      recvVideo.srcObject = e.stream;
    }
  });
};
const stopConn = async () => {
  if (!conn) return;
  await conn.disconnect();
  encodedStreams = [];

  recvVideo.pause();
  recvVideo.srcObject = null;
};

</script>

</html>